{% extends "base.html" %}
{% load static %}

{% block content %}
<div class="p-4">
  <h2 class="text-xl font-semibold mb-3">My Deliveries</h2>
  <div id="driver-app"></div>
</div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>

<!-- Django-resolved URLs (outside verbatim so template tags work) -->
<script>
  window.DELIVERY_API = {
    list: "{% url 'orders:driver-deliveries-api' %}",
    routePattern: "{% url 'orders:driver-route-api' 0 %}",  // -> /orders/apis/driver/route/0/
    pickupPattern: "/api/deliveries/0/pickup/",              // replaced at runtime with id
    deliverPattern: "/api/deliveries/0/deliver/"             // replaced at runtime with id
  };
</script>

{% verbatim %}
<script>
(function () {
  // --- knobs ---
  const ACTIVE = ["assigned", "picked_up", "en_route"];
  const SPEED_KMPH = 30;    // fallback ETA if route API not used/slow
  const MIN_PING_MS = 8000; // throttle driver pings
  const MIN_MOVE_M = 25;    // only ping if moved > X meters

  // --- helpers ---
  const num = (v) => v == null || v === "" ? null : Number(v);
  const latlngFixed = (lat, lng) => {
    lat = num(lat); lng = num(lng);
    if (lat == null || lng == null) return { lat: null, lng: null };
    // If someone swapped them (e.g., 36.8, -1.29), fix it.
    if (Math.abs(lat) > 90 && Math.abs(lng) <= 180) { const t = lat; lat = lng; lng = t; }
    return { lat, lng };
  };

  // Pure Haversine (used by chooseBestDest and component)
  function haversineKm(a, b) {
    const R = 6371;
    const dLat = (b.lat - a.lat) * Math.PI / 180;
    const dLng = (b.lng - a.lng) * Math.PI / 180;
    const s1 = Math.sin(dLat / 2) ** 2 +
               Math.cos(a.lat * Math.PI / 180) * Math.cos(b.lat * Math.PI / 180) * Math.sin(dLng / 2) ** 2;
    return 2 * R * Math.asin(Math.sqrt(s1));
  }

  // Choose the destination orientation (as-is vs swapped) that is closer to the driver
  const chooseBestDest = (driver, dest) => {
    if (!driver || driver.lat == null || driver.lng == null ||
        !dest || dest.lat == null || dest.lng == null) return dest;

    const dAsIs = haversineKm(driver, dest);
    const dSwap = haversineKm(driver, { lat: dest.lng, lng: dest.lat });
    return (isFinite(dAsIs) && isFinite(dSwap) && dSwap + 0.1 < dAsIs)
      ? { lat: dest.lng, lng: dest.lat }
      : dest;
  };

  const hasGeoAPI = () =>
    typeof navigator !== "undefined" &&
    navigator.geolocation &&
    typeof navigator.geolocation.watchPosition === "function";

  // Leaflet icon
  function iconTruck() {
    return L.divIcon({
      className: "driver-truck-icon",
      html: '<div style="display:inline-flex;align-items:center;justify-content:center;width:26px;height:26px;border-radius:50%;background:#2563eb;color:white;box-shadow:0 1px 4px rgba(0,0,0,.25)"><img src="/favicon.ico" alt="driver" style="width:16px;height:16px;border-radius:3px"/></div>',
      iconSize: [26, 26],
      iconAnchor: [13, 13]
    });
  }

  new Vue({
    el: "#driver-app",
    delimiters: ["[[", "]]"],

    data() {
      return {
        deliveries: [],
        activeId: null,

        // filters + styling helpers
        statusFilter: "all", // all | pending | assigned | picked_up | en_route | delivered | cancelled

        // geo + websocket
        watchId: null,
        ws: null,
        wsReady: false,
        outbox: [],

        // throttling
        lastSentAt: 0,
        lastSent: null,

        // map state
        map: null,
        driverMarker: null,
        destMarker: null,
        routeLine: null,
        etaText: "—",

        // route throttling
        lastRouteKey: null,
        lastRouteAt: 0,

        refreshTimer: null
      };
    },

    computed: {
      active() { return this.deliveries.find(d => d.id === this.activeId) || null; },
      activeList() { return this.deliveries.filter(d => ACTIVE.includes(d.status)); },
      filteredDeliveries() {
        if (this.statusFilter === "all") return this.deliveries;
        return this.deliveries.filter(d => d.status === this.statusFilter);
      }
    },

    mounted() {
      this.refresh();
      this.refreshTimer = setInterval(() => this.refresh(), 10_000);
    },

    beforeDestroy() {
      this._stopGeoWatch();
      this._closeWS();
      if (this.refreshTimer) clearInterval(this.refreshTimer);
    },

    methods: {
      // ---------- UI meta ----------
      statusMeta(s) {
        const meta = {
          pending:    { label: "Pending",    cls: "bg-gray-100 text-gray-800", pct: 10 },
          assigned:   { label: "Assigned",   cls: "bg-amber-100 text-amber-800", pct: 25 },
          picked_up:  { label: "Picked up",  cls: "bg-blue-100 text-blue-800",   pct: 60 },
          en_route:   { label: "En route",   cls: "bg-indigo-100 text-indigo-800", pct: 80 },
          delivered:  { label: "Delivered",  cls: "bg-emerald-100 text-emerald-800", pct: 100 },
          cancelled:  { label: "Cancelled",  cls: "bg-red-100 text-red-800", pct: 0 },
        };
        return meta[s] || { label: s, cls: "bg-gray-100 text-gray-800", pct: 0 };
      },
      fmt(dt) { if (!dt) return "—"; try { return new Date(dt).toLocaleString(); } catch(_) { return dt; } },
      progressPct(d) { return this.statusMeta(d.status).pct; },

      // ---------- Data loading ----------
      async refresh() {
        try {
          const r = await fetch(window.DELIVERY_API.list, { credentials: "same-origin" });
          if (!r.ok) return;
          const arr = await r.json();

          this.deliveries = arr.map(d => {
            // normalize coords + pick best dest orientation
            const last = latlngFixed(d.last_lat, d.last_lng);
            let dest   = latlngFixed(d.dest_lat, d.dest_lng);
            if (last.lat != null && last.lng != null && dest.lat != null && dest.lng != null) {
              dest = chooseBestDest(last, dest);
            }
            return Object.assign({}, d, {
              last_lat: last.lat, last_lng: last.lng,
              dest_lat: dest.lat, dest_lng: dest.lng
            });
          });

          if (!this.activeId && this.activeList.length) this.activeId = this.activeList[0].id;

          // keep map marker in sync with snapshot
          if (this.map && this.active && this.active.last_lat != null) {
            this._updateDriver(this.active.last_lat, this.active.last_lng);
          }
        } catch (e) {
          console.warn("refresh failed:", e);
        }
      },

      // ---------- REST helpers ----------
      async postJSON(url, body) {
        const res = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-CSRFToken": this._csrftoken() },
          credentials: "same-origin",
          body: JSON.stringify(body || {})
        });
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      },
      _csrftoken() {
        const m = document.cookie.match('(^|;)\\s*csrftoken\\s*=\\s*([^;]+)'); return m ? m.pop() : "";
      },
      _isoFrom(dateStr, timeStr) {
        if (!dateStr || !timeStr) return null; // Today | Now -> backend uses now()
        return new Date(`${dateStr}T${timeStr}`).toISOString();
      },

      // ---------- Tracking ----------
      track(id) {
        if (this.activeId !== id) {
          this._resetMapOverlays();
          this._stopGeoWatch();
          this._closeWS();
        }
        this.activeId = id;

        this.$nextTick(() => {
          this._ensureMap();
          this._ensureWS();
        });

        if (!hasGeoAPI()) return;
        this._stopGeoWatch();
        this.watchId = navigator.geolocation.watchPosition(
          (pos) => this._sendPing(pos.coords.latitude, pos.coords.longitude),
          (err) => { console.warn("watchPosition error:", err); },
          { enableHighAccuracy: true, maximumAge: 5000, timeout: 20000 }
        );
      },

      stopTracking() {
        this._stopGeoWatch();
        this._closeWS();
      },

      _stopGeoWatch() {
        if (this.watchId != null && hasGeoAPI() && typeof navigator.geolocation.clearWatch === "function") {
          try { navigator.geolocation.clearWatch(this.watchId); } catch (_) {}
        }
        this.watchId = null;
      },

      // ---------- WebSocket ----------
      _ensureWS() {
        if (this.ws && this.wsReady) return;
        const url = (location.protocol === "https:" ? "wss://" : "ws://") +
                    location.host + `/ws/delivery/track/${this.activeId}/`;
        this.ws = new WebSocket(url);

        this.ws.onopen = () => {
          this.wsReady = true;
          while (this.outbox.length) this.ws.send(JSON.stringify(this.outbox.shift()));
        };

        // Route all messages through a single handler
        this._wireWS(this.ws);

        this.ws.onclose = () => {
          this.wsReady = false;
          setTimeout(() => { if (this.activeId) this._ensureWS(); }, 1500);
        };
      },

      _wireWS(ws) {
        ws.onmessage = (e) => {
          const msg = JSON.parse(e.data || "{}");
          this._onWSMessage(msg);
        };
      },

      _onWSMessage(msg) {
        if (msg.type === "position_update") {
          const p = latlngFixed(msg.lat, msg.lng);
          if (p.lat != null) this._updateDriver(p.lat, p.lng);
        } else if (msg.type === "status_update") {
          // expected: {type, id, status, picked_up_at?, delivered_at?}
          const i = this.deliveries.findIndex(x => x.id === msg.id);
          if (i >= 0) {
            const cur = this.deliveries[i];
            const next = Object.assign({}, cur, {
              status: msg.status ?? cur.status,
              picked_up_at: msg.picked_up_at ?? cur.picked_up_at,
              delivered_at: msg.delivered_at ?? cur.delivered_at,
            });
            this.$set(this.deliveries, i, next);
          }
          if (this.activeId === msg.id) this._paintStatic();
        } else if (msg.type === "status") {
          // legacy: {type:"status", status: "..."} for current active
          const d = this.deliveries.find(x => x.id === this.activeId);
          if (d && msg.status) d.status = msg.status;
        }
      },

      _closeWS() {
        if (this.ws) { try { this.ws.close(); } catch (_) {} }
        this.ws = null;
        this.wsReady = false;
        this.outbox = [];
      },

      _sendPing(lat, lng) {
        lat = num(lat); lng = num(lng);
        if (lat == null || lng == null) return;

        const now = Date.now();
        const movedEnough = !this.lastSent || (haversineKm(this.lastSent, { lat, lng }) * 1000) > MIN_MOVE_M;
        if (now - this.lastSentAt < MIN_PING_MS || !movedEnough) {
          this._updateDriver(lat, lng);
          return;
        }
        this.lastSentAt = now; this.lastSent = { lat, lng };

        const packet = { type: "position_update", lat, lng };
        if (this.wsReady) this.ws.send(JSON.stringify(packet));
        else this.outbox.push(packet);

        this._updateDriver(lat, lng);
      },

      // ---------- Status actions (POST to API + optional WS broadcast) ----------
      async markPickedUp() {
        if (!this.activeId) return;
        const id = this.activeId;
        const dateEl = document.getElementById(`pick-date-${id}`);
        const timeEl = document.getElementById(`pick-time-${id}`);
        const whenISO = this._isoFrom(dateEl?.value, timeEl?.value);

        const url = window.DELIVERY_API.pickupPattern.replace("/0/", `/${id}/`);
        try {
          const data = await this.postJSON(url, whenISO ? { when: whenISO } : {});
          const i = this.deliveries.findIndex(x => x.id === id);
          if (i >= 0) {
            this.$set(this.deliveries, i, Object.assign({}, this.deliveries[i], {
              status: data.status, picked_up_at: data.picked_up_at
            }));
          }
          if (this.wsReady) this.ws.send(JSON.stringify({ type: "status", status: "picked_up" }));
        } catch (e) {
          alert("Pickup failed: " + e.message);
        }
      },

      async markDelivered() {
        if (!this.activeId) return;
        const id = this.activeId;
        const dateEl = document.getElementById(`deliv-date-${id}`);
        const timeEl = document.getElementById(`deliv-time-${id}`);
        const whenISO = this._isoFrom(dateEl?.value, timeEl?.value);

        const url = window.DELIVERY_API.deliverPattern.replace("/0/", `/${id}/`);
        try {
          const data = await this.postJSON(url, whenISO ? { when: whenISO } : {});
          const i = this.deliveries.findIndex(x => x.id === id);
          if (i >= 0) {
            this.$set(this.deliveries, i, Object.assign({}, this.deliveries[i], {
              status: data.status, delivered_at: data.delivered_at
            }));
          }
          if (this.wsReady) this.ws.send(JSON.stringify({ type: "status", status: "delivered" }));
          this.stopTracking();
        } catch (e) {
          alert("Deliver failed: " + e.message);
        }
      },

      // ---------- Map ----------
      _ensureMap() {
        const shell = this.$el.querySelector("#map-shell");
        if (!shell) return;

        if (!this.map) {
          const c = this._center();
          this.map = L.map(shell).setView([c.lat, c.lng], (c.lat === 0 && c.lng === 0) ? 2 : 13);
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19, attribution: "&copy; OpenStreetMap contributors"
          }).addTo(this.map);
        }
        this._paintStatic();
      },

      _center() {
        const a = this.active || {};
        if (a.last_lat != null) return { lat: a.last_lat, lng: a.last_lng };
        if (a.dest_lat != null) return { lat: a.dest_lat, lng: a.dest_lng };
        return { lat: 0, lng: 0 };
      },

      _resetMapOverlays() {
        if (this.routeLine) { try { this.map.removeLayer(this.routeLine); } catch (_) {} this.routeLine = null; }
        if (this.driverMarker) { try { this.map.removeLayer(this.driverMarker); } catch (_) {} this.driverMarker = null; }
        if (this.destMarker) { try { this.map.removeLayer(this.destMarker); } catch (_) {} this.destMarker = null; }
        this.etaText = "—";
        this.lastRouteKey = null;
        this.lastRouteAt = 0;
      },

      _paintStatic() {
        const a = this.active; if (!a) return;

        if (a.dest_lat != null) {
          const pt = [a.dest_lat, a.dest_lng];
          if (!this.destMarker)
            this.destMarker = L.marker(pt, { title: "Destination" }).addTo(this.map);
          else
            this.destMarker.setLatLng(pt);
        }

        if ((a.last_lat != null || this.driverMarker) && a.dest_lat != null) {
          this._drawRoadRoute();
        }
      },

      async _drawRoadRoute() {
        const a = this.active; if (!a || a.dest_lat == null) return;

        const lat = (this.driverMarker ? this.driverMarker.getLatLng().lat : a.last_lat);
        const lng = (this.driverMarker ? this.driverMarker.getLatLng().lng : a.last_lng);
        if (lat == null || lng == null) return;

        // throttle expensive route call
        const key = `${this.activeId}:${lat.toFixed(5)},${lng.toFixed(5)}:${a.dest_lat.toFixed(5)},${a.dest_lng.toFixed(5)}`;
        const now = Date.now();
        if (this.lastRouteKey === key && now - this.lastRouteAt < 60_000) return;
        this.lastRouteKey = key; this.lastRouteAt = now;

        const url = window.DELIVERY_API.routePattern.replace(/\/0\/?$/, `/${this.activeId}/`);
        const r = await fetch(url, { credentials: "same-origin" });
        if (!r.ok) return;
        const j = await r.json();

        // accept multiple shapes from the API
        let coords = j.coords || [];
        if (!coords.length && j.geometry && Array.isArray(j.geometry.coordinates)) {
          // GeoJSON: [lon, lat] -> [lat, lng]
          coords = j.geometry.coordinates.map(([x, y]) => [y, x]);
        }
        if (!coords.length) return;

        if (!this.routeLine) this.routeLine = L.polyline(coords, { weight: 3, color: '#f97316' }).addTo(this.map);
        else this.routeLine.setLatLngs(coords);

        if (typeof j.distance_km === "number" && typeof j.duration_min === "number" && isFinite(j.duration_min)) {
          this.etaText = `${j.distance_km.toFixed(2)} km · ~${Math.round(j.duration_min)} min`;
        }

        const b = this.routeLine.getBounds();
        if (b && b.isValid()) this.map.fitBounds(b, { padding: [20, 20] });
      },

      _updateDriver(lat, lng) {
        if (!this.map) return;
        lat = num(lat); lng = num(lng);
        if (lat == null || lng == null) return;

        if (!this.driverMarker)
          this.driverMarker = L.marker([lat, lng], { icon: iconTruck(), zIndexOffset: 500 }).addTo(this.map);
        else
          this.driverMarker.setLatLng([lat, lng]);

        this._drawRoadRoute();

        const a = this.active;
        if (a && a.dest_lat != null) {
          const dist = haversineKm({ lat, lng }, { lat: a.dest_lat, lng: a.dest_lng });
          if (!/km/.test(this.etaText)) {
            const etaMin = Math.round((dist / SPEED_KMPH) * 60);
            this.etaText = isFinite(etaMin) ? `${dist.toFixed(2)} km · ~${etaMin} min` : "—";
          }
        }
      }
    },

    template: `
      <div class="space-y-4">
        <!-- Status filter tabs -->
        <div class="mb-1 flex flex-wrap gap-2 text-xs">
          <button v-for="s in ['all','pending','assigned','picked_up','en_route','delivered','cancelled']"
                  :key="s"
                  @click="statusFilter=s"
                  class="px-3 py-1 rounded-full border transition"
                  :class="statusFilter===s ? 'bg-black text-white border-black' : 'bg-white text-gray-700 hover:bg-gray-50'">
            [[ s.replace('_',' ') ]]
          </button>
        </div>

        <!-- List -->
        <ul v-if="filteredDeliveries.length" class="divide-y rounded-2xl border bg-white shadow-sm">
          <li v-for="d in filteredDeliveries" :key="d.id" class="p-4">
            <div class="flex items-start justify-between gap-4">
              <div class="min-w-0 flex-1">
                <div class="flex items-center gap-2">
                  <div class="font-semibold truncate">Delivery #[[ d.id ]] — Order #[[ d.order_id ]]</div>
                  <span class="px-2 py-0.5 rounded-full text-[11px]" :class="statusMeta(d.status).cls">
                    [[ statusMeta(d.status).label ]]
                  </span>
                </div>

                <div class="mt-2 grid sm:grid-cols-3 gap-3 text-xs text-gray-600">
                  <div>
                    <div class="text-gray-500">Assigned at</div>
                    <div class="font-medium">[[ fmt(d.assigned_at) ]]</div>
                  </div>
                  <div>
                    <div class="text-gray-500">Picked up at</div>
                    <div class="font-medium">[[ fmt(d.picked_up_at) ]]</div>
                  </div>
                  <div>
                    <div class="text-gray-500">Delivered at</div>
                    <div class="font-medium">[[ fmt(d.delivered_at) ]]</div>
                  </div>
                </div>

                <!-- Progress bar -->
                <div class="mt-3 h-2 rounded-full bg-gray-100 overflow-hidden">
                  <div class="h-2 bg-black transition-all" :style="{ width: progressPct(d)+'%' }"></div>
                </div>
              </div>

              <div class="shrink-0 flex flex-col items-end gap-2">
                <button class="px-3 py-1 rounded-xl bg-indigo-600 text-white text-xs hover:opacity-90"
                        @click="track(d.id)">
                  [[ activeId===d.id ? 'Tracking' : 'Track' ]]
                </button>

                <!-- Only for the active card: date/time controls -->
                <div v-if="activeId===d.id" class="mt-1 grid grid-cols-1 gap-2 text-[11px]">
                  <div class="border rounded-xl p-2">
                    <div class="font-semibold mb-1">Picked up at</div>
                    <div class="flex items-center gap-1">
                      <input :id="`pick-date-${d.id}`" type="date" class="border rounded px-2 py-1">
                      <input :id="`pick-time-${d.id}`" type="time" class="border rounded px-2 py-1">
                      <button class="px-2 py-1 rounded border" @click="$event.target.closest('div').querySelector(`#pick-date-${d.id}`).value=''; $event.target.closest('div').querySelector(`#pick-time-${d.id}`).value=''">Today/Now</button>
                      <button class="px-2 py-1 rounded bg-blue-600 text-white" @click="markPickedUp()">Save</button>
                    </div>
                  </div>

                  <div class="border rounded-xl p-2">
                    <div class="font-semibold mb-1">Delivered at</div>
                    <div class="flex items-center gap-1">
                      <input :id="`deliv-date-${d.id}`" type="date" class="border rounded px-2 py-1">
                      <input :id="`deliv-time-${d.id}`" type="time" class="border rounded px-2 py-1">
                      <button class="px-2 py-1 rounded border" @click="$event.target.closest('div').querySelector(`#deliv-date-${d.id}`).value=''; $event.target.closest('div').querySelector(`#deliv-time-${d.id}`).value=''">Today/Now</button>
                      <button class="px-2 py-1 rounded bg-green-600 text-white" @click="markDelivered()">Save</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </li>
        </ul>
        <div v-else class="text-gray-600">No deliveries.</div>

        <!-- Map/ETA panel -->
        <div v-if="active" class="rounded-2xl border bg-white shadow-sm">
          <div class="p-2 text-sm text-gray-600">
            Tracking delivery #[[ active.id ]] · ETA: [[ etaText ]]
          </div>
          <div id="map-shell" class="h-80 w-full" style="height: 22rem;"></div>
        </div>
      </div>
    `
  });
})();
</script>
{% endverbatim %}
{% endblock %}
