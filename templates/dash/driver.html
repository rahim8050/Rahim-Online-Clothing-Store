{% extends "base.html" %}
{% load static %}

{% block content %}
<div class="p-4">
  <h2 class="text-xl font-semibold mb-3">My Deliveries</h2>
  <div id="driver-app"></div>
</div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>

<!-- URLs resolved by Django (outside verbatim) -->
<script>
  window.DELIVERY_API = {
    list: "{% url 'orders:driver-deliveries-api' %}",
    routePattern: "{% url 'orders:driver-route-api' 0 %}"  // -> "/orders/apis/driver/route/0/"
  };
</script>

{% verbatim %}
<script>
(function(){
  const ACTIVE = ["assigned","picked_up","en_route"];
  const SPEED_KMPH = 30;     // fallback ETA
  const MIN_PING_MS = 8000;  // throttle sends
  const MIN_MOVE_M  = 25;    // only send if moved >25m

  new Vue({
    el: "#driver-app",
    delimiters: ["[[", "]]"],
    data: {
      deliveries: [],
      activeId: null,

      // geo & WS
      watchId: null,
      ws: null,
      wsReady: false,
      outbox: [],

      // client throttling
      lastSentAt: 0,
      lastSent: null,

      // map state
      map: null, driverMarker: null, destMarker: null, routeLine: null,
      etaText: "—",

      // route throttling
      lastRouteKey: null,
      lastRouteAt: 0,

      refreshTimer: null
    },

    computed: {
      active()     { return this.deliveries.find(d => d.id === this.activeId) || null; },
      activeList() { return this.deliveries.filter(d => ACTIVE.includes(d.status)); }
    },

    mounted() {
      this.refresh();
      this.refreshTimer = setInterval(() => this.refresh(), 10000);
    },

    beforeDestroy() {
      if (this.watchId) navigator.geolocation.clearWatch(this.watchId);
      if (this.ws) this.ws.close();
      if (this.refreshTimer) clearInterval(this.refreshTimer);
    },

    methods: {
      async refresh() {
        const r = await fetch(window.DELIVERY_API.list, { credentials: "same-origin" });
        if (!r.ok) return;
        this.deliveries = await r.json();
        if (!this.activeId && this.activeList.length) this.activeId = this.activeList[0].id;

        if (this.map && this.active && this.active.last_lat != null) {
          this._updateDriver(this.active.last_lat, this.active.last_lng);
        }
      },

      track(id) {
        this.activeId = id;
        this.$nextTick(() => {
          this._ensureMap();
          this._ensureWS();
        });

        if (!("geolocation" in navigator)) return;
        if (this.watchId) navigator.geolocation.clearWatch(this.watchId);
        this.watchId = navigator.geolocation.watchPosition(
          pos => this._sendPing(pos.coords.latitude, pos.coords.longitude),
          () => {}, { enableHighAccuracy: true, maximumAge: 0, timeout: 20000 }
        );
      },

      stopTracking() {
        if (this.watchId) { navigator.geolocation.clearWatch(this.watchId); this.watchId = null; }
        if (this.ws) { this.ws.close(); this.ws = null; this.wsReady = false; this.outbox = []; }
      },

      _ensureWS() {
        if (this.ws && this.wsReady) return;
        const url = (location.protocol === "https:" ? "wss://" : "ws://") +
                    location.host + `/ws/deliveries/${this.activeId}/`;
        this.ws = new WebSocket(url);

        this.ws.onopen = () => {
          this.wsReady = true;
          while (this.outbox.length) this.ws.send(JSON.stringify(this.outbox.shift()));
        };

        this.ws.onmessage = (e) => {
          const msg = JSON.parse(e.data || "{}");
          if (msg.event === "driver_ping") {
            this._updateDriver(msg.lat, msg.lng);
          } else if (msg.event === "status") {
            const d = this.deliveries.find(x => x.id === msg.delivery_id);
            if (d) d.status = msg.status;
          }
        };

        this.ws.onclose = () => { this.wsReady = false; setTimeout(() => this._ensureWS(), 1500); };
      },

      _sendPing(lat, lng) {
        const now = Date.now();
        const movedEnough = !this.lastSent || (this._haversineKm(this.lastSent, {lat,lng}) * 1000) > MIN_MOVE_M;
        if (now - this.lastSentAt < MIN_PING_MS || !movedEnough) {
          this._updateDriver(lat, lng);
          return;
        }
        this.lastSentAt = now; this.lastSent = { lat, lng };

        const packet = { type: "ping", lat, lng };
        if (this.wsReady) this.ws.send(JSON.stringify(packet));
        else this.outbox.push(packet);

        this._updateDriver(lat, lng); // optimistic
      },

      markPickedUp() {
        if (!this.activeId) return;
        this._ensureWS();
        const packet = { type: "action", action: "picked_up" };
        if (this.wsReady) this.ws.send(JSON.stringify(packet)); else this.outbox.push(packet);
      },

      markDelivered() {
        if (!this.activeId) return;
        this._ensureWS();
        const packet = { type: "action", action: "delivered" };
        if (this.wsReady) this.ws.send(JSON.stringify(packet)); else this.outbox.push(packet);
        this.stopTracking();
      },

      _ensureMap() {
        const shell = this.$el.querySelector("#map-shell");
        if (!shell) return;

        if (!this.map) {
          const c = this._center();
          this.map = L.map(shell).setView([c.lat, c.lng], 13);
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19, attribution: "&copy; OpenStreetMap"
          }).addTo(this.map);
        }
        this._paintStatic();
      },

      _center() {
        const a = this.active || {};
        if (a.last_lat != null) return { lat: a.last_lat, lng: a.last_lng };
        if (a.dest_lat != null) return { lat: a.dest_lat, lng: a.dest_lng };
        return { lat: 0, lng: 0 };
      },

      _paintStatic() {
        const a = this.active; if (!a) return;
        if (a.dest_lat != null) {
          if (!this.destMarker)
            this.destMarker = L.marker([a.dest_lat, a.dest_lng], { title: "Destination" }).addTo(this.map);
          else
            this.destMarker.setLatLng([a.dest_lat, a.dest_lng]);
        }
        if ((a.last_lat != null || this.driverMarker) && a.dest_lat != null) {
          this._drawRoadRoute();
        }
      },

      async _drawRoadRoute() {
        const a = this.active; if (!a || a.dest_lat == null) return;

        const lat = (this.driverMarker ? this.driverMarker.getLatLng().lat : a.last_lat);
        const lng = (this.driverMarker ? this.driverMarker.getLatLng().lng : a.last_lng);
        if (lat == null || lng == null) return;

        const key = `${this.activeId}:${lat.toFixed(5)},${lng.toFixed(5)}:${a.dest_lat.toFixed(5)},${a.dest_lng.toFixed(5)}`;
        const now = Date.now();
        if (this.lastRouteKey === key && now - this.lastRouteAt < 60000) return; // 60s throttle
        this.lastRouteKey = key; this.lastRouteAt = now;

        const url = window.DELIVERY_API.routePattern.replace(/\/0\/?$/, `/${this.activeId}/`);
        const r = await fetch(url, { credentials: "same-origin" });
        if (!r.ok) return;
        const j = await r.json();
        const coords = j.coords || [];
        if (!coords.length) return;

        if (!this.routeLine) this.routeLine = L.polyline(coords, { weight: 3 }).addTo(this.map);
        else this.routeLine.setLatLngs(coords);

        if (typeof j.distance_km === "number" && typeof j.duration_min === "number" && isFinite(j.duration_min)) {
          this.etaText = `${j.distance_km.toFixed(2)} km · ~${Math.round(j.duration_min)} min`;
        }

        this.map.fitBounds(this.routeLine.getBounds(), { padding: [20,20] });
      },

      _updateDriver(lat, lng) {
        if (!this.map) return;
        if (!this.driverMarker)
          this.driverMarker = L.circleMarker([lat, lng], { radius: 7 }).addTo(this.map);
        else
          this.driverMarker.setLatLng([lat, lng]);

        this._drawRoadRoute();

        const a = this.active;
        if (a && a.dest_lat != null) {
          const dist = this._haversineKm({lat,lng}, {lat:a.dest_lat, lng:a.dest_lng});
          if (!/km/.test(this.etaText)) {
            const etaMin = Math.round((dist / SPEED_KMPH) * 60);
            this.etaText = isFinite(etaMin) ? `${dist.toFixed(2)} km · ~${etaMin} min` : "—";
          }
        }
      },

      _haversineKm(a,b){
        const R=6371, dLat=(b.lat-a.lat)*Math.PI/180, dLng=(b.lng-a.lng)*Math.PI/180;
        const s1 = Math.sin(dLat/2)**2 +
          Math.cos(a.lat*Math.PI/180)*Math.cos(b.lat*Math.PI/180)*Math.sin(dLng/2)**2;
        return 2*R*Math.asin(Math.sqrt(s1));
      }
    },

    template: `
      <div>
        <ul v-if="deliveries.length" class="divide-y rounded border bg-white">
          <li v-for="d in deliveries" :key="d.id" class="p-2 flex items-center justify-between">
            <div>
              <div class="font-medium">Delivery #[[ d.id ]] — Order #[[ d.order_id ]]</div>
              <div class="text-xs text-gray-600">Status: [[ d.status ]]</div>
            </div>
            <div class="flex items-center">
              <button class="px-3 py-1 rounded bg-indigo-600 text-white text-xs" @click="track(d.id)">Track</button>
              <button v-if="activeId===d.id && d.status!=='picked_up' && d.status!=='delivered'"
                      class="ml-2 px-3 py-1 rounded bg-blue-600 text-white text-xs"
                      @click="markPickedUp()">Picked up</button>
              <button v-if="activeId===d.id && d.status!=='delivered'"
                      class="ml-2 px-3 py-1 rounded bg-green-600 text-white text-xs"
                      @click="markDelivered()">Delivered</button>
            </div>
          </li>
        </ul>
        <div v-else class="text-gray-600">No deliveries yet.</div>

        <div v-if="active" class="mt-4 rounded border bg-white">
          <div class="p-2 text-sm text-gray-600">
            Tracking delivery #[[ active.id ]] · ETA: [[ etaText ]]
          </div>
          <div id="map-shell" class="h-80 w-full"></div>
        </div>
      </div>`
  });
})();
</script>
{% endverbatim %}
{% endblock %}
